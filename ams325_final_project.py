# -*- coding: utf-8 -*-
"""AMS325 Final Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jK51gvWkby_1eMQ9ZmgtNFnliophtgU8
"""

import cv2
import os
import matplotlib.pyplot as plt
import numpy as np
from skimage.transform import rotate

# Load Image

img = cv2.imread("test_img.png", cv2.IMREAD_GRAYSCALE)
size = img.shape[0] # Square Image
plt.imshow(img, cmap='gray')

path = './results/'
if not os.path.exists(path):   # if the path does not exist, create a directory
    os.mkdir(path)

# Convert Image to Sinogram
angles = np.arange(1,181) # you can change the step
sinogram_img = np.zeros((size, len(angles)), dtype=np.float32)
# every column is the detector signal from a view angle

for i in range(180):
    # rotate the image by counterclockwise so the x-ray is clockwise relevantly
    # projection is basically summing over columns
    sinogram_img[:,i] = rotate(img, angles[i]).sum(axis=0)

plt.imshow(sinogram_img,cmap='gray')
plt.imsave('./results/Sinogram.png',sinogram_img,cmap='gray')
plt.title('sinogram')
plt.show()

"""### **Part 2) Using the backward projection to reconstruct the CT image from the sinogram.**"""

def backprojection (image):
  bp_img = np.zeros((image.shape[0],image.shape[0]))
   #initialized back projection image to matrix with zeros

  for i in range (image.shape[1]): #repeat for all columns of sinogram
    temp = np.tile(image[:,i],(image.shape[0],1))
    #use np.tile function to copy ith column of sinogram to a matrix

    temp = rotate(temp,-i)#-i to rotate counterclockwisely
    bp_img = bp_img + temp

  print(temp.shape)
  return bp_img

bp_img = backprojection(sinogram_img)
plt.imsave("./results/Reconstruction by back projection.png",bp_img,cmap='gray')
plt.imshow(bp_img, cmap='gray')
plt.title('Reconstruction by back projection')
plt.axis('off')
plt.savefig("./results/Part2)Reconstruction by back projection.png")
plt.show()

"""### **Part 3)Histogram Equalization**"""

bp_img = cv2.imread('./results/Reconstruction by back projection.png')

def histEqual(img):
  m=img.shape[0] #get dimension of input image
  n=img.shape[1]
  img_array = np.asarray(img) #convert image to an array
  # use cv2.calcHist() function to get the frequency of pixels, divide by M*N (which were found previously) to get normalized histogram
  pdf = cv2.calcHist([img],[0],None,[256],[0,256])/(m*n)
  cdf=np.cumsum(pdf) #sum over the pdf to get the cdf
  func=(256-1)*cdf #intensity transformation function
  func_int = np.array(func, dtype=np.uint8) #convert float to int
  img_1D= list(img_array.flatten()) #flatten input array to 1D list
  output_array = [func_int[pixel] for pixel in img_1D ] #apply transformation
  output_array = np.reshape(np.asarray(output_array),img_array.shape) #reshape the image
  num_pixel = output_array.shape[0]*output_array.shape[1] #calculate number of pixels
  output_pdf = cv2.calcHist([output_array],[0],None,[256],[0,256])/(num_pixel)
  output_cdf = np.cumsum(output_pdf)
  return output_array,pdf,output_pdf,cdf,output_cdf

histEqual_bp_img,pdf_before,pdf_after,cdf_before,cdf_after = histEqual(bp_img)
plt.imshow(histEqual_bp_img,cmap='gray')
plt.title("Reconstruction by back projection after histogram equalization")
plt.axis('off')
plt.savefig("./results/Part3)Reconstruction by back projection after histogram equalization.png")
plt.show()

compare = np.hstack((bp_img,histEqual_bp_img)) #stacking images side-by-side
cv2.imwrite('./results/Part3)comparison image.png',compare)
plt.imshow(compare) #compare input with output
plt.axis('off')

plt.plot(pdf_before,label='pdf before')
plt.plot(pdf_after, label="pdf after")
plt.legend()
plt.savefig('./results/Part3)comparison pdf.png')

plt.plot(cdf_before,label='cdf before')
plt.plot(cdf_after, label="cdf after")
plt.legend()
plt.savefig('./results/Part3)Comparison cdf.png')

"""### **Part 4) Frequency Filtering**"""

def sinoFilter(sino):
  #use np.fft.fftn to perform fourier transform on sinogram from part 1
  s = np.fft.fftn(sino)
  #print(s.shape)
  ramp = np.abs(np.linspace(-1,1,800)) #define the ramp filter

  #fourier transform the ramp filter using np.fft.fftfreq
  ramp = np.abs(np.fft.fftfreq(s.shape[0],d=np.diff(ramp)[0]))

  s_tilda = (s.T * ramp).T #apply the filter to the sinogram
  #print(s_tilda.dtype)
  filtered_sinogram = np.fft.ifftn(s_tilda)
  #use np.fft.ifftn to perform inverse fourier transform
  filtered_sinogram = np.real(filtered_sinogram)
  #and then use np.real() to get rid of imaginary values
  return filtered_sinogram

ramp = np.abs(np.linspace(-1,1,800))
plt.plot(ramp)
plt.title('ramp filter')
plt.show()

filtered_sinogram = sinoFilter(sinogram_img)

plt.imshow(filtered_sinogram,cmap='gray')
plt.title('sinogram after ramp filtering')
plt.axis('off')
plt.savefig("./results/Part4)sinogram after ramp filtering.png")
plt.show()

"""### **Part 5)Filtered back projection**"""

#use the function defined in part 2) to perform the filtered back projection
FBP = backprojection(filtered_sinogram)
plt.imshow(FBP,cmap='gray')
plt.title('Reconstruction by filtered back projection')
plt.axis('off')
plt.savefig("./results/Part5)Reconstruction by filtered back projection.png")
plt.show()

"""### **Part 6)X-ray detector out of order.Some row of original sinogram is black, test what will happen.**"""

blackRowSinoImg = sinogram_img.copy()
blackRowSinoImg[100]=0 #make the 100th row black
plt.imshow(blackRowSinoImg,cmap='gray')

#use functions defined in previous parts to test the results
blackRowFilteredSino = sinoFilter(blackRowSinoImg)
blackRowFBP = backprojection(blackRowFilteredSino)
plt.imshow(blackRowFBP,cmap='gray')
plt.title('Reconstruction by filtered back projection (black row)')
plt.axis('off')
plt.savefig("./results/Part6)Black row FBP.png")
plt.show()

"""### **Part 7)View angle of x-ray sources out of order. Some column of original sinogram is black, test what will happen.**"""

blackColSinoImg = sinogram_img.copy()
blackColSinoImg[:,100]=0 #make the 100th column black
plt.imshow(blackColSinoImg,cmap='gray')

blackColFilteredSino = sinoFilter(blackColSinoImg)
blackColFBP = backprojection(blackColFilteredSino)
plt.imshow(blackColFBP,cmap='gray')
plt.title('Reconstruction by filtered back projection (one black column)')
plt.axis('off')
plt.savefig("./results/Part7)Black column FBP (1 black column).png")
plt.show()

blackColSinoImg2 = sinogram_img.copy()
blackColSinoImg2[:,95:100]=0 #make more columns black
blackColSinoImg2[:,:5]=0
plt.imshow(blackColSinoImg2,cmap='gray')

blackColFilteredSino2 = sinoFilter(blackColSinoImg2)
blackColFBP2 = backprojection(blackColFilteredSino2)
plt.imshow(blackColFBP2,cmap='gray')
plt.title('Reconstruction by filtered back projection (more black columns)')
plt.axis('off')
plt.savefig("./results/Part7)Black column FBP (more black columns).png")
plt.show()

blackColSinoImg3 = sinogram_img.copy()
diagonal_length = min(blackColSinoImg3.shape[0], blackColSinoImg3.shape[1])

blackColSinoImg3[np.arange(diagonal_length), np.arange(diagonal_length)] = 0
plt.imshow(blackColSinoImg3, cmap='gray')
plt.show()

blackColFilteredSino3 = sinoFilter(blackColSinoImg3)
blackColFBP3 = backprojection(blackColFilteredSino3)
plt.imshow(blackColFBP3,cmap='gray')

"""In part 6),we made the 100th row of the original sinogram black to simulate the situation where some of the x-ray detectors are out of order. Then we performed the filtered back projection. Based on the output image we got, we can see that it has a great impact on the output image. You can observe the "ring" or the "circle" artifacts on the image. That makes sense because if we lost one detector, then we lost details from each angle, and when we do the rotation it will cause the black ring, thus the image quality is greatly reduced.

However, in part 7), when we made one of the columns black to simulate the situation where some view angles of the x-ray sources are out of order, it didn't have a notable impact on the overall quality of the image if you compare to the results we got from part 5). That's probably due to the fact that we only lost one angle of details and we still have 179 angles of details can work properly. When we made more columns black, then the output image contains notable artifacts, for example those white straight lines.

That is our analysis on the influence of detectors and view angles on the reconstructed image.
Itâ€™s overall successful and met the expectations.

"""